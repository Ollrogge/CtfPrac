use std::env;
use std::fs;
use std::path::PathBuf;
use std::process::Command;

fn main() {
    println!("cargo:rerun-if-changed=cpio_files/");
    let cur_dir = std::env::current_dir().expect("Unable to obtain current dir");

    let binary_path = PathBuf::from(std::env::var_os("CARGO_BIN_FILE_EXPLOIT_exploit").unwrap());
    let cpio_files_path = cur_dir.parent().unwrap().join("cpio_files");
    let cpio_archive_name = "my_rootfs.cpio";
    let cpio_archive_path = cpio_files_path.parent().unwrap().join(cpio_archive_name);

    if !cpio_files_path.exists() {
        // TODO: unpack cpio
        fs::create_dir_all(&cpio_files_path).expect("Failed to create cpio_files directory");
    }

    //panic!("test: {} {}", binary_path.display(), cpio_files_path.display());
    let status = Command::new("sudo")
        .arg("cp")
        .arg(binary_path.as_os_str())
        .arg(cpio_files_path.join("exp").as_os_str())
        .status()
        .expect("Failed to copy exploit to dir");

    if !status.success() {
        panic!("Failed to copy exploit to dir");
    }

    let _ = std::fs::remove_file(&cpio_archive_path);

    let status = Command::new("sudo")
        .arg("sh")
        .arg("-c")
        .arg(format!(
            "cd {} && find . -print0 | cpio --null -ov --format=newc > {}",
            cpio_files_path.display(),
            cpio_archive_path.display()
        ))
        .status()
        .expect("Failed to create CPIO archive");

    if !status.success() {
        panic!("Failed to create CPIO archive");
    }
}
